# Garkatron CLOX Implementation

### Chunks of Bytecode

#### isn't memory efficient

JLOX isn't memory efficient because a simple expression turns into a big collection of objects overcharged with Java Objects data.

The CPUs process works faster than RAM, so it uses the cache to compenste.
Every time that CPU reads bytes keep a little part of data in the cache to read later.
If we keep some data in the cache and then read from it, our program will be faster as a roadrunner.
JVM Object header tends to pull out of the ram our data becous tends to push objects away from each other.

#### Compiling issues

Performance has a cost:
Less portability (LLVM's help's)
Harder work (Includes LLVM's)


#### Bytecode

Bytecode it's a collection of custom instructions to handle our data around the memory without think about specific instrucion set of the target machine.
It's a simple way to transform native instructions to our simple instructions and handle it by our own.
It's portable if we write it in C or another compiled language and it's faster than a tree-walk interpreter.


#### A dynamic array of instructions

We don't know about the size of the array before start compilink a chunk, so it must be dynamic.

Cache friendly, dense storage
constant time indexed element lookup
constat tie appending to the end of the array

**how works?:**

Allocate a new array with more capacity.
Copy the existing elements from the old array to the new one.
Store the new capacity.
Delete the old array.
Update code to point to the new array.
Store the element in the new array now that there is room.
Update the count.

#### Disassembler

A debug tool to see the bytecode generated by our chunk.

#### Constants

For small fixed-size values like integers, many instruction sets store the value directly in the code stream right after the opcode. These are called immediate instructions because the bits for the value are immediately after the opcode.
These constants are saved in a separated "constant data" region in the binary.
Then it's loaded with it's memory address.

JVM associates a constant pool for each compiled class.
In CLOX we store all constants on it.

When VM execute a OP_CONSTANT it loads the data for the usage.
Each OPCODE has its own operands and its hown format.


#### Line Information

In jlox line info lives in tokens, in clox lives in an array in the code chunks. Inneficient but easy.

#### Value arrays


#### Challenges
https://danluu.com/malloc-tutorial/
https://github.com/danluu/malloc-tutorial

https://mliezun.github.io/2020/04/11/custom-malloc.html

1. How works reallocate(), malloc() and free();
https://medium.com/@andrestc/implementing-malloc-and-free-ba7e7704a473


https://tharikasblogs.blogspot.com/p/how-to-write-your-own-malloc-and-free.html
