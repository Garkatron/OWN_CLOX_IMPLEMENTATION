#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "hashmap.h"

#define HASHMAP_MAX_LOAD 0.75

static HashEntry *findEntry(HashEntry *entries, int capacity, const void *key,
                        uint32_t (*hashFunc)(const void *),
                        bool (*equalsFunc)(const void *, const void *)) {
    uint32_t index = hashFunc(key) % capacity;
    HashEntry *tombstone = NULL;

    for (;;) {
        HashEntry *entry = &entries[index];
        if (entry->key == NULL) {
            if (entry->value == NULL) {
                return tombstone != NULL ? tombstone : entry;
            } else {
                if (tombstone == NULL) tombstone = entry;
            }
        } else if (equalsFunc(entry->key, key)) {
            return entry;
        }

        index = (index + 1) % capacity;
    }
}

static void adjustCapacity(HashMap *map, int capacity) {
    
    map->kLast = NULL;
    map->vLast = NULL;

    HashEntry *entries = malloc(sizeof(HashEntry) * capacity);
    for (int i = 0; i < capacity; i++) {
        entries[i].key = NULL;
        entries[i].value = NULL;
    }

    map->count = 0;
    for (int i = 0; i < map->capacity; i++) {
        HashEntry *entry = &map->entries[i];
        if (entry->key == NULL) continue;

        HashEntry *dest = findEntry(entries, capacity, entry->key, map->hashFunc, map->equalsFunc);
        dest->key = entry->key;
        dest->value = entry->value;
        map->count++;
    }

    free(map->entries);
    map->entries = entries;
    map->capacity = capacity;
}

void initHashMap(HashMap *map,
                 uint32_t (*hashFunc)(const void *),
                 bool (*equalsFunc)(const void *, const void *),
                 void (*freeKey)(void *),
                 void (*freeValue)(void *)) {
    map->count = 0;
    map->capacity = 0;
    map->entries = NULL;
        map->kLast = NULL;
    map->vLast = NULL;
    map->hashFunc = hashFunc;
    map->equalsFunc = equalsFunc;
    map->freeKey = freeKey;
    map->freeValue = freeValue;

}

void freeHashMap(HashMap *map) {
    if (map->freeKey || map->freeValue) {
        for (int i = 0; i < map->capacity; i++) {
            HashEntry *entry = &map->entries[i];
            if (entry->key && map->freeKey) map->freeKey(entry->key);
            if (entry->value && map->freeValue) map->freeValue(entry->value);
        }
    }
    free(map->entries);
    initHashMap(map, map->hashFunc, map->equalsFunc, map->freeKey, map->freeValue);
}

bool hashMapSet(HashMap *map, void *key, void *value) {
    if (map->count + 1 > map->capacity * HASHMAP_MAX_LOAD) {
        int newCap = map->capacity < 8 ? 8 : map->capacity * 2;
        adjustCapacity(map, newCap);
    }

    HashEntry *entry = findEntry(map->entries, map->capacity, key, map->hashFunc, map->equalsFunc);
    bool isNew = (entry->key == NULL && entry->value == NULL);
    if (isNew) map->count++;

    entry->key = key;
    entry->value = value;

    map->kLast = &entry->key;
    map->vLast = &entry->value;

    return isNew;
}

bool hashMapGet(HashMap *map, const void *key, void **valueOut) {
    if (map->count == 0) return false;

    if (map->kLast != NULL && map->equalsFunc(map->kLast, key)) {
        *valueOut = map->vLast;
        return true;
    }

    HashEntry *entry = findEntry(map->entries, map->capacity, key, map->hashFunc, map->equalsFunc);
    if (entry->key == NULL) return false;

    *valueOut = entry->value;
    return true;
}

bool hashMapDelete(HashMap *map, const void *key) {
    if (map->count == 0) return false;

    HashEntry *entry = findEntry(map->entries, map->capacity, key, map->hashFunc, map->equalsFunc);
    if (entry->key == NULL) return false;

    if (map->kLast != NULL && map->equalsFunc(map->kLast, key))
    {
        map->vLast = NULL;
        map->kLast = NULL;
    }

    if (map->freeKey) map->freeKey(entry->key);
    if (map->freeValue) map->freeValue(entry->value);

    entry->key = NULL;
    entry->value = (void *)1; // Tombstone
    return true;
}

void hashMapPrint(HashMap *map) {
    printf("HashMap content:\n");
    for (int i = 0; i < map->capacity; i++) {
        HashEntry entry = map->entries[i];
        if (entry.key && entry.value)
            printf("  [%d] key=%p, value=%p\n", i, entry.key, entry.value);
    }
}

uint32_t intHash(const void *ptr) {
    int i = *(int *)ptr;
    return (uint32_t)i;
}

bool intEquals(const void *a, const void *b) {
    return *(int *)a == *(int *)b;
}

void freeInt(void *ptr) {
    free(ptr);
}